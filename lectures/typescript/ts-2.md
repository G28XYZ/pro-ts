---
title: "TypeScript — Лекция 2"
---

# TypeScript — Лекция 2

[Каталог](../README.md) · [Все лекции TypeScript](./README.md) · ← [Лекция 1](./ts-1.md) · [Лекция 3](./ts-3.md) →

---

## 1) Главная мысль про TypeScript
- TS не «чинит» JavaScript и почти ничего не добавляет в **runtime**: он добавляет **язык описания типов** и проверки/подсказки компилятора.
- После компиляции **типы исчезают** (в JS остаётся только код).

---

## 2) Мир типов vs мир значений. Аннотация и вывод типов
### Аннотация (`:`)
```ts
const name: string = "Alex";
let age: number = 25;
```

### Вывод типов (inference)
Если тип не указан — TS пытается вывести его из контекста.
```ts
const n = 42;   // обычно выводится более конкретно (литерал)
let x = 42;     // обычно шире: number
```

### Когда явно писать типы (практическое правило)
- **Публичный API** (экспортируемые функции/методы/классы) — **аннотировать всегда**: легче читать контракт и меньше «случайных» breaking changes.
- Внутренний код — часто достаточно вывода типов (меньше «шума»).

```ts
// Публичный контракт фиксируем явно
export function formatPrice(value: number, currency: "EUR" | "USD"): string {
  return `${value} ${currency}`;
}
```

---

## 3) Что такое `any` и почему он опасен
- `any` = «что угодно», TS **почти ничего не проверяет**.
- `any` **заражает** выражения: всё, что вычисляется из `any`, часто тоже становится `any`.

```ts
let a: any = null;

a.foo().bar().baz;      // компилятор молчит
const b = a + 10;       // b: any
```

### Когда `any` всё же уместен
- Интероп с «сырым» JS (без типов).
- Крайний случай: вы **точно** уверены, что тип корректен, но компилятор не справился (лучше локально и осознанно).

---

## 4) `unknown` — безопасная альтернатива `any`
- `unknown` принимает любое значение, но **не даёт ничего с ним делать**, пока вы не сузите тип.

```ts
function printLen(v: unknown) {
  // v.length; // ошибка: неизвестно, что это
  if (typeof v === "string") {
    console.log(v.length); // ok
  }
}
```

---

## 5) Базовые типы, как в JS (и важная деталь)
Примитивы: `boolean`, `string`, `number`, `bigint`, `symbol`, `null`, `undefined`  
Объекты: `object` / `Object` (функции, массивы, даты — тоже объекты)

> Типы для примитивов в TS пишутся **с маленькой буквы** (`string`, `number` и т.п.).

---

## 6) `strictNullChecks`: почему лучше держать включённым
- Исторически `null` мог вести себя как «подтип объекта».
- Опция `strictNullChecks` делает работу с `null/undefined` безопаснее: компилятор не даст «случайно» засунуть `null` туда, где его быть не должно.

```ts
let s: string = "ok";
// s = null; // ошибка при strictNullChecks
```

---

## 7) `symbol` / `unique symbol` и `typeof` в мире типов
- `symbol` — множество всех символов.
- `const`-символ может получить тип **`unique symbol`**, а `let` — обычно просто `symbol`.
- Чтобы сослаться на **тип конкретного символа**, нужен `typeof` (в мире типов).

```ts
const ID = Symbol("id");  // ID: unique symbol
let id2 = Symbol("id");   // id2: symbol

type IdType = typeof ID;  // тип конкретного символа

const obj: any = {};
obj[ID] = 123;
```

---

## 8) Литеральные типы (тип = конкретное значение)
Можно задавать тип конкретной константой:
```ts
type Answer = 42;
const a: Answer = 42;
// const b: Answer = 43; // ошибка

type Direction = "left" | "right" | "up" | "down";
```

---

## 9) Объединения (Union) `A | B`
- Вертикальная черта `|` = «или»: значение может быть одним из вариантов.
- Внутри обычно нужно **сужать** тип через проверки.

```ts
function toStr(v: number | string) {
  return typeof v === "string" ? v : v.toString();
}
```

### Важный момент с массивами и скобками
```ts
type A = string | number;

let x: A[];              // (string | number)[]
let y: string | number[]; // string OR number[]
```

---

## 10) Размеченные объединения (Discriminated unions) — идея
Если варианты объединения имеют общий «маркер» (дискриминант), TS проще и безопаснее сужает тип.

```ts
type Shape =
  | { kind: "circle"; r: number }
  | { kind: "square"; a: number };

function area(s: Shape) {
  if (s.kind === "circle") return Math.PI * s.r ** 2;
  return s.a ** 2;
}
```

---

## 11) Template literal types (шаблонные строковые типы)
Можно описывать строки по паттерну (как «регулярка» для мира типов).

```ts
type Method = "GET" | "POST";
type Path = "/users" | "/orders";
type Endpoint = `${Method} ${Path}`;

const e: Endpoint = "GET /users";
```

---

## 12) Массивы: `T[]` vs `Array<T>`
Оба варианта эквивалентны, разница в удобстве записи:
```ts
const a: string[] = ["a", "b"];
const b: Array<string> = ["a", "b"];
```

Часто `Array<T>` удобнее в сложных выражениях (меньше скобок).

---

## 13) Псевдонимы типов (`type`)
Чтобы не копировать один и тот же сложный тип:
```ts
type Value = string | number | boolean;

function f(v1: Value, v2: Value) {}
```

---

## 14) Директивы компилятора: `@ts-ignore` и `@ts-expect-error`
### `@ts-ignore`
- «Не проверяй следующую строку».
- Опасно: можно скрыть реальную ошибку (опечатку и т.п.).

### `@ts-expect-error`
- «На этой строке *ожидается* ошибка».
- Если после обновления TS/кода ошибки не станет — TS начнёт ругаться. Удобно для:
  - временных обходов багов компилятора
  - тестов типизации

```ts
// @ts-expect-error: временный обход бага типизации
someLegacyFn("bad-arg");
```

---

## 15) Мини-команды: поставить и запустить
```bash
npm i -D typescript
npx tsc --init
npx tsc --watch
```

---

### Быстрый чек-лист (что запомнить)
- Публичный API аннотируй.
- `any` — только осознанно и локально.
- `unknown` + type guards — безопасный путь.
- `strictNullChecks` лучше не выключать.
- Union `|` + сужение типов — база TS.
- `@ts-expect-error` предпочтительнее, чем `@ts-ignore`, когда вы *ожидаете* ошибку.
