---
title: "TypeScript — Лекция 6"
---

# TypeScript — Лекция 6

[Каталог](../README.md) · [Все лекции TypeScript](./README.md) · ← [Лекция 5](./ts-5.md) · [Лекция 7](./ts-7.md) →

---

## 1) Что такое полиморфизм (быстро)

Полиморфизм = **один интерфейс использования** для разных типов данных.

### 1.1 Параметрический (истинный) полиморфизм
Один и тот же код работает с разными типами (обычно generics).
```ts
function id<T>(x: T): T {
  return x;
}

id(1);        // number
id("hello");  // string
id({ a: 1 }); // { a: number }
```

### 1.2 Ad-hoc / специальный полиморфизм
Один интерфейс, но **разные реализации** (классы/интерфейсы).
```ts
interface Storage {
  delete(key: string): void;
}

class StringStorage implements Storage {
  delete(key: string) { /* ... */ }
}

class NumberStorage implements Storage {
  delete(key: string) { /* ... */ }
}

function useStorage(s: Storage) {
  s.delete("k"); // вызывается разный код в зависимости от реализации
}
```

### 1.3 Полиморфизм подтипов (subtype polymorphism)
Там, где ожидается базовый тип, можно передать его подтип.
```ts
class Animal { move(): void {} }
class Dog extends Animal { bark(): void {} }

function walk(a: Animal) { a.move(); }
walk(new Dog()); // ok
```

---

## 2) Зачем нужна вариативность (variance)

Вариативность — это правило, **когда тип можно заменить его подтипом/надтипом** в составных типах.

Термины:
- **Ковариантность**: можно заменить на **подтип** (T → SubT)
- **Контрвариантность**: можно заменить на **надтип** (T → SuperT)
- **Бивариантность**: можно в обе стороны (и подтип, и надтип)
- **Инвариантность**: нельзя никуда (только ровно T)

---

## 3) Вариативность у функций: главное правило

Тип функции:
- **контрвариантен по аргументам**
- **ковариантен по возвращаемому значению**

Интуиция:
- Если функция принимает *более общий* аргумент — ей легче угодить (контрвариантность).
- Если функция возвращает *более конкретный* результат — это безопаснее (ковариантность).

### 3.1 Пример с иерархией A ← B ← C
```ts
class A { sayA() {} }
class B extends A { sayB() {} }
class C extends B { sayC() {} }

type F = (x: B) => B;

// ОК: аргумент стал шире (A), результат стал уже (C)
const ok1: F = (x: A) => new C();

// ОШИБКА: аргумент стал уже (C) — небезопасно
// const bad1: F = (x: C) => new B();
```

---

## 4) `strictFunctionTypes`: почему надо включать

`strictFunctionTypes` делает параметры **функциональных типов** контрвариантными (как и должно быть).

Если выключить — параметры часто становятся **бивариантными** → можно написать валидный TS-код, который **упадёт в runtime**.

Рекомендация:
- держать `strict: true` или хотя бы `strictFunctionTypes: true`.

---

## 5) Важный нюанс TS: **методы** ведут себя иначе, чем **функции**

В TS есть две распространённые формы:

### 5.1 Функциональный тип (строже при `strictFunctionTypes`)
```ts
type Handler = (x: B) => void;
```

### 5.2 Метод в интерфейсе/классе (часто бивариантен по параметрам)
```ts
interface I {
  handle(x: B): void; // метод
}
```

Из-за исторической совместимости TS может разрешать вещи, которые для функций были бы запрещены,
и это **может привести к runtime-ошибкам**.

### Практический совет
Когда вам важна строгая проверка входных параметров — **описывайте коллбеки как свойства-функции**, а не методы:

✅ Строже:
```ts
interface I {
  handle: (x: B) => void; // свойство-функция
}
```

⚠️ Мягче (может быть бивариантно):
```ts
interface I {
  handle(x: B): void; // метод
}
```

---

## 6) Variance в generics: `in`, `out`, `in out`

Для обобщённых типов (контейнеров) TS позволяет *подсказать* вариативность параметра типа:

- `out T` — **ковариантный** параметр (тип **производится**, например `get(): T`)
- `in T` — **контрвариантный** параметр (тип **потребляется**, например `set(x: T): void`)
- `in out T` — **инвариантный** (строгое равенство параметра)
- если ничего не указано — TS пытается **вывести** (и иногда получится бивариантность)

Примеры:

### 6.1 `out` — только «возвращаем»
```ts
interface Producer<out T> {
  get(): T;
}
```

### 6.2 `in` — только «принимаем»
```ts
interface Consumer<in T> {
  put(x: T): void;
}
```

### 6.3 `in out` — и принимаем, и возвращаем (инвариант)
```ts
interface Box<in out T> {
  get(): T;
  set(x: T): void;
}
```

### Зачем это нужно
- явный контракт (легче читать и поддерживать),
- компилятору проще проверять совместимость,
- меньше шансов «случайно» получить бивариантность.

---

## 7) Ограничения и «дыры» (важно знать)

- Даже с `strictFunctionTypes` и `in/out` **всё равно можно “хакнуть” систему** и написать код,
  который проходит проверки, но падает в runtime (особенно из-за структурной типизации и особенностей наследования).
- В лекции подчёркивается, что TS изначально создавался как инструмент для удобства работы с JS, а не как 100% безопасный язык.

---

## 8) Мини-чек-лист безопасности
- ✅ Включить `strictFunctionTypes` (лучше `strict: true`)
- ✅ Коллбеки описывать **как функциональные типы** и/или **свойства-функции**, а не методы
- ✅ Там, где важна строгость контейнеров, использовать `in` / `out` / `in out`
- ✅ Не полагаться на TS как на «гарант отсутствия runtime-ошибок»
- ✅ Избегать `any`, `@ts-ignore` и небезопасных assertions — они легко ломают гарантии

---
